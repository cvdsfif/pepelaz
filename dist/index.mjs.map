{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export class NotNull { }\nexport const notNull = new NotNull();\n\nexport abstract class DataField<T> {\n    readonly defaultIfNull: () => T | null | NotNull;\n\n    constructor(\n        defaultValueOrFunction: T | null | NotNull | (() => T | null | NotNull) = null\n    ) {\n        if (typeof defaultValueOrFunction === \"function\") this.defaultIfNull = (defaultValueOrFunction as () => T | null | NotNull);\n        else this.defaultIfNull = () => defaultValueOrFunction;\n    };\n\n    abstract convert(field: any, level: string): T;\n\n    unmarshal(field: any, level = \"\"): T | null {\n        if (!field && field !== false && field !== 0) {\n            const din = this.defaultIfNull();\n            if (din instanceof NotNull) throw new Error(`Null value is not allowed for the field ${level}`);\n            return (din as (T | null));\n        }\n        return this.convert(field, level);\n    }\n};\nexport type FieldType<T> = T extends DataField<infer R> ? R : T;\nexport type DbRecord<T> = T extends FieldObject<infer S> ? DbRecord<S> : {\n    [P in keyof T]?: FieldType<T[P]> | null;\n}\n\nexport class FunctionField<Arg extends DataField<any>, Ret extends DataField<any>>{\n    readonly argument: Arg;\n    readonly retval: Ret;\n\n    constructor(argument: Arg, retval: Ret) {\n        this.argument = argument;\n        this.retval = retval;\n    }\n}\nexport const functionField =\n    <Arg extends DataField<any>, Ret extends DataField<any>>(arg: Arg, ret: Ret) =>\n        new FunctionField<Arg, Ret>(arg, ret);\n\nexport type DataInterfaceDefinition = {\n    [P in any]: FunctionField<DataField<any>, DataField<any>>;\n}\nexport type FunctionFieldType<T> = T extends FunctionField<infer Arg, infer Ret> ? (arg: FieldType<Arg>) => FieldType<Ret> : T;\nexport type AsyncFunctionFieldType<T> = T extends FunctionField<infer Arg, infer Ret> ? (arg: FieldType<Arg>) => Promise<FieldType<Ret>> : T;\nexport type FunctionReturnType<T> = T extends FunctionField<infer Arg, infer Ret> ? FieldType<Ret> : T;\nexport type FunctionArgumentType<T> = T extends FunctionField<infer Arg, infer Ret> ? FieldType<Arg> : T;\nexport type DataInterface<T> = {\n    [P in keyof T]: FunctionFieldType<T[P]>;\n}\n\nclass IntegerField extends DataField<number>{ convert = (field: any): number => parseInt(field); };\nexport const integerField = (defaultIfNull: number | null | NotNull | (() => number) = null) => new IntegerField(defaultIfNull);\nclass FloatField extends DataField<number>{ convert = (field: any): number => parseFloat(field); };\nexport const floatField = (defaultIfNull: number | null | NotNull | (() => number) = null) => new FloatField(defaultIfNull);\nexport class BigIntField extends DataField<bigint>{ convert = (field: any): bigint => BigInt(`${field}`.replace(/(^-?\\d+)(.*)/, \"$1\")); };\nexport const bigIntField = (defaultIfNull: bigint | null | NotNull | (() => bigint) = null) => new BigIntField(defaultIfNull);\nclass StringField extends DataField<string>{ convert = (field: any): string => `${field}`; };\nexport const stringField = (defaultIfNull: string | null | NotNull | (() => string) = null) => new StringField(defaultIfNull);\nexport class DateField extends DataField<Date>{ convert = (field: any): Date => new Date(field); };\nexport const dateField = (defaultIfNull: Date | null | NotNull | (() => Date) = null) => new DateField(defaultIfNull);\nclass BooleanField extends DataField<boolean>{ convert = (field: any): boolean => Boolean(field).valueOf(); };\nexport const booleanField = (defaultIfNull: boolean | null | NotNull | (() => boolean) = null) => new BooleanField(defaultIfNull);\nexport class VoidField extends DataField<void>{ convert = (field: void) => { } }\nexport const voidField = () => new VoidField();\n\nclass FieldArray<T> extends DataField<(T | null)[]>{\n    readonly members: DataField<T>;\n\n    constructor(members: DataField<T>, defaultValueOrFunction: ((T | null)[] | null | NotNull) = null) {\n        super(defaultValueOrFunction);\n        this.members = members;\n    }\n\n    convert(field: any[], level = \"\"): (T | null)[] {\n        return new Array(...field).map((element, index) => this.members.unmarshal(element, `::${level}::${index}`));\n    }\n};\nexport const fieldArray = <T>(member: DataField<T>, defaultIfNull: ((T | null)[] | null | NotNull | (() => (T | null))) = null) =>\n    new FieldArray(member, defaultIfNull);\n\nexport const stringifyWithBigints = (value: any) => {\n    (BigInt.prototype as any).toJSON = function () { return this.toString(); }\n    return JSON.stringify(value);\n}\n\nexport type FieldObjectDefinition = {\n    [P in any]: DataField<any>;\n}\nexport class FieldObject<T extends FieldObjectDefinition> extends DataField<DbRecord<T>>{\n    readonly definition: T;\n\n    constructor(definition: T, defaultValueOrFunction: null | NotNull | T = null) {\n        super(defaultValueOrFunction);\n        this.definition = definition;\n    }\n\n    convert(record: any, level = \"\"): DbRecord<T> {\n        return Object.keys(this.definition).reduce((accumulator, key) => {\n            const matchingField =\n                record[key] ??\n                record[key.toLowerCase()] ??\n                record[convertUppercaseIntoUnderscored(key)];\n            const unmarshalledValue = this.definition[key].unmarshal(matchingField, `::${level}::${key}`);\n            (accumulator as any)[key] = unmarshalledValue;\n            return accumulator;\n        }, new Object() as DbRecord<T>);\n    }\n}\nexport const fieldObject = <T extends FieldObjectDefinition>(definition: T, defaultValueOrFunction: null | NotNull | T = null) =>\n    new FieldObject(definition, defaultValueOrFunction);\n\nconst convertUppercaseIntoUnderscored = (s: String) => s.replace(/[A-Z]/g, match => `_${match.toLowerCase()}`);\n\nexport const unmarshal = (template: DataField<any> | FieldObjectDefinition, field: any) => {\n    if (template instanceof DataField) {\n        return (template as DataField<any>).unmarshal(field);\n    }\n    return fieldObject(template).unmarshal(field);\n}\n\nexport interface IApiProps {\n    name: string,\n    description: string,\n    definition: DataInterfaceDefinition\n}\n"],"mappings":"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","names":[]}